Car dashboard theme
===================

```
2025-08-01		1.7.0	Done
```


This is mostly just a lark/proof-of-concept.
I don't really think it's likely to look *good*, but it might be fun, and would be a good testcase for something I've been wondering about - different angular contexts.

In nearly all cases so far the various time periods have been represented by whole circles (360 degrees, 2pi radians) in keeping with the clock idea.
But in some cases it might be nice to be able to represent full-range by less than a whole a circle to get more of a dial effect.
Some fancy watches occasionally use sub-dials like this, but a more classic example is an old-school car dashboard.
The tacho, speedo, fuel gauge are all represented by cicle segments - 2/3 or 3/4 or a quarter circle or whatever.

Put together a car dashboard theme to try this out.
Could have the month as the tacho, year as the speedo, and odometer as the date/year of day. Maybe a fuel gauge for seasons.



Start hacking
-------------

Starting from the wall-clock.

index.html?theme=car-dashboard&date=1988-03-14&test=true


Don't think I have the circle centres right.
Some gridlines would help.



Transforms
----------

Turns out quite a lot can be done with just simple transforms.
CSS transforms are even working for me in both FF and Chromium, which is quite neat.
However they're having the unintended consequence of overwriting the rotation transforms on the hands, so I'll have to split those apart.

The hand code is getting a bit tortured...
I'd made some changes for the vintage theme to allow for specifying which drawing function to use.
Now I need to break the code apart again.

Sort of going.


Month Markers
-------------

I've split up the two dials, they're still full-circle though.
Was about to put some matching ticks in for the year hand when I realised I don't have a method for that.
The *only* tick method I have is the old `getPeriodDayTicks`.

So I need something newish.
I'd like to take the opportunity to think about ways to improve and abstract the old tick code while I'm at it.

For a while I've wanted to rename 'ticks' to something more general like 'markers'.
That could cover over a few other variants I've thought about at various times:
* circles / dots
* triangles or wedge shapes
* simplified (non-arc) or proper sectors as markers
* start or mid markers
* diamond shapes
* Characters/emojis as markers

Gonna come back to this - wanna tackle angles first.


Angular Context
---------------

I've chopped something together that is starting to work.

Inadvertently I've made the end relative to the start instead of absolute, but this is actually better as more kinds of angular contexts, eg greater than one revolution, are possible.

Have both dials working now in a basic way


Wireframe and Grid
------------------

I've rejigged the getClockSVG methods so that method now sits in the ThemeBase, and the themes now have getThemeSVG methods instead.
The main difference is that the SVG tag has been promoted to the ThemeBase, and I can add common elements easily across themes.

In this case, a graph-paper like grid that gets turned on in wireframe mode to help with layout.

Paying off immediately, spotted a a bug.


Month sector bug
----------------

Looks like I've munged something to do with the month sectors - they're not lining up with their day sector/markers at the moment, hopefully this is just a recently added bug.

Not lining up with days either, it's out fractionally, so not a counting/off-by-one error.

It's:

	addRadians(displayDate.monthArray);

`addRadians` currently only works for evenly spaced array items, so it's evenly spacing the months (bzzzzt).

Need another way of calcing radians for unevenly spaced arrays.

Changes made in:

	8202901c Get dial working for months: remove radians from getMonthArray, move to themes

Months were previously using:

	'radians'      : dateRangeRadians(startDate, nextMonth),



`dateRangeRadians` is still available, and is being used by the season, quarter and week functions.

Need to decide what to do about it. Do I just wodge in angular context, or try to generalise `addRadians`?

I think a general date range addRadians function would be useful.
The array items needn't even necessarily be aligned or consecutive - just as long as they have start and end dates we can calc radians within a context.
Could also be useful for things like custom date-range highlights, which I'll actually want pretty soon.

Now I have another weirder bug...
Something is completely stopping the date.js script in its tracks - no error, just the script isn't loading or available.
It must be a syntax error of some sort, but I can't find it.
Thas was weird:

	Uncaught SyntaxError: redeclaration of formal parameter radiansStartdate.js:133:8note: Previously declared at line 129, column 41

Wasn't showing up in a normal load, only in a pared down test file.
For future reference, I was using a default param with the same name as a const.
Should really have shown up somewhere between vscode, ff, chromium....

I've changed the themes over to use a new `addDateRangeRadians` function to fix the month sector misalignment, and have added angle context to `dateRangeRadians`.
But it is now in an awkward state of being incorrect for date ranges outside what the arc represents - will need to add some testing/rules.
At the moment the only year crossing date range is probably summer in season-out so look at that, but will need a general solution.


dateRangeRadians
----------------

Currently stands like this:

	function dateRangeRadians(date1, date2, radiansStart=0, radiansLength=Math.TAU) {...}

But it's incomplete like that.
Currently it's exhibiting as a bug on the year side of the dashboard theme.
It's assuming the dates take place within a standard circle.

Ugh.
Struggling with this one - too many assumptions.
Lets generalise it a bit.
What if the array items were non-sequential/non-correlated, ie just an arbitrary set of date ranges.
And we wanted to calc their radian parameters over an arbitrary arc.

We'd need
	* the array of date periods of interest (holidays/seasons/sprints whatever)
	* The angular range over which to distribute them
	* The date range represented by the whole range

So if the arc is 180 degrees, and the arc represents a whole year, then the date period sectors can be placed within.

So I need some sort of compact way or expressing a date-angle mapping.

```js
	const diy1 = daysInYear(date1);
	const diy2 = daysInYear(date2);

	const start = divisionRadians(diy1, dayOfYear(date1), radiansStart, radiansLength).start;
	const end   = divisionRadians(diy2, dayOfYear(date2), radiansStart, radiansLength).start + (Math.TAU * yearDifference(date1, date2)); // INCORRECT for arcs
```
There are more assumptions in here too.
The `daysInYear` and `dayOfYear` calcs aren't necessarily correct - they need to be replaced by something sensitive to the date range represented by the full arc.
So need something like:

```js
	const daysInRange = daysInRange(periodStart, periodEnd);

	const dop1 = dayOfPeriod(date1, periodStart, periodEnd);
	const dop2 = dayOfPeriod(date2, periodStart, periodEnd);

	const start = divisionRadians(daysInRange, dop1, radiansStart, radiansLength).start;
	const end   = divisionRadians(daysInRange, dop2, radiansStart, radiansLength).start;
```

That will be closer.
Need to write `daysInRange` and `dayOfPeriod` though.

I think they're actually the same function - `dayDifference(date1,date2)` which will just be a generalised version of the current `dayOfYear(date)`.

`dayOfPeriod` might still be needed - it could return null if the date is outside the range  - not sure yet.


### Experimenting with small classes
The signatures of some of these functions are starting to get a bit hard to read.
I'm going to toy with changing some things over to small classes for obviously grouped parameters.
Eg:
```js
class DateRange {
	constructor(start, end) {
		this.start = new Date(start);
		this.end = new Date(end);
	}
}/* DateRange */
```
Not sure yet if this will help or hinder read/write-ability, will try it for a little while.
Also *technically* these might be better described as intervals, will stick with range for now.

Actually i might need another terminology here - I also want to be able to describe ranges in terms of start+offset pairs that I'd started using for radian width.

Using 'range' for one and 'interval' for the other is tempting...
For really simple things I could even get away with using completely generic classes, ie just Range or Interval.
Could even subclass for datatypes, might be good for some things, not sure I want to though.

For radians i'll use Delta, something like this:
```
class RadianDelta {
	constructor(start = 0, delta = Math.TAU) {
		this.start = start;
		this.delta = delta;
	}
}/* RadianDelta */
```


### Zero basing for divisionRadians & divisionDegrees

These have both been 1-based for a while, but I need them both to become 0-based to make more sense with arc-division mappings.

It makes more sense for the zeroth div to start at 0 and go up from there, and for the -1th div to be negative.

So I'm going to change these over.
Might get messy.

	divisionRadians
		addRadians
		getPeriodDaySectors

	done

	divisionDegrees

		only used by the hands

	done


Those are in place now, now extrapolating the division-arc mapping makes more sense.


dateRadians & outlier handling
------------------------------

It's still a mess at the moment, but slowly making progress.
dateRangeRadians is still the main source of problems.

Need to be more systematic about how range outliers are handled in a generic division-arc mapping.
Three options I think I'll need:
* truncate - if a range falls partly outside the window, truncate it to the window
* extrapolate - extrapolate outlying ranges to beyond the window
* wrap - attempt to 'wrap' outlying ranges back into the window by some method
* negative - what to do with negative ranges

I think I should first try to get a function to sit between dateRangeRadians and divisionRadians.

Need `dateRadians`.


### custom date arrays

Most of the clocks are working ow with the new scheme, but lightning and season-out both make use of some custom arrays being built in `date.js`.

I've updated lightning and looks like it's working now.

### Summer

The custom season array for `season-out` is where this might get interesting though.
It uses (used) a trick to get summer to cross back into the current year.
Need to see if any of the above options might work for this.

I've gone ahead and done the same updates to the season array as I'd done for week and quarter.
Currently the season array uses a negative date range for summer.
I was expecting this to break somehow, but the summer sector has drawn "correctly" straight off the bat.

This time around I want to properly understand what's happening.
At the moment:
* Summer is a negative date range, eg
	```
	s = new DateRange(new Date(2004,11,1), new Date(2004,2,1))
	s.length()
		-275
	```
* Summer's sector goes backwards and has a negative width, and the middle is in the wrong spot:
	```
	​​​start: 5.75100294509607
	end: 1.0300303782261615
	​​​middle: 3.3905166616611155
	​​​width: -4.720972566869908
	```
	If there *had* been a sector label, it would have been wrong. (Have just tested - it *is* wrong.)
* The sector seems to be drawn clockwise ("correctly"), which is unexpected - i'd thought it would have gone counter-clockwise.
	It goes forwards because of the start-end radians which cross zero clockwise.

So its "worked", but it hasn't really worked properly.

So what to do?

I think the best option will be to try to extrapolate Summer into the next year, keeping the date and radian ranges positive, and taking care to get the day count correct for February.

Okay looking good so far, have faked a summer end into next year that will display correctly and give the correct width and middle.

*If* at some point in the future I have to display the start and end dates for summer, this current ruse will also be up.

Ultimately Summer (or northern Winter) for a given year will have to be split into two date ranges, along with any other year crossing date ranges.
This display hack will have to be applied on an as-needed basis.
That will come soon enough.

An example would be if I displayed a whole year on a non-whole circle, such as the car-dashboard's year dial.
I have something else in mind for seasons for the car dashboard, but to prove the point I should build a theme intentionally designed to show this such as a 180 degree year clock.


Mini status
-----------
* Have separate dials going for the dashboard done with translate transforms
* Have custom date range - arc range mostly working to get the dial effect, but the code is probably a mess
* Have started using mini classes for things like date and radian ranges to neaten up some bits of code - still in a halfway state
* All clocks appear to be displaying correctly

Todo:
* Need some solid focus on markers for the dashboard and in general: svg:use+transform; d as a css property
* Need to work out how to apply internal shadows/lighting for the dashboard - probably require a cutout or three
* trip meter, fuel gauge, warning lights
* get carbon-fibre crosshatching sorted out - maybe look into an svg background instead
* Fix the date dial to 31 days, but turn off extra day lights per month
* Redlines/redzones
* Looks more like a motorbike dash at the moment, see if can be made more car-ish



Inset drop shadow
-----------------

Found a totally usable SVG inset drop shadow filter:
	https://css-tricks.com/adding-shadows-to-svg-icons-with-css-and-svg-filters/

Going to tinker with it for shadow and lighting effects.
Will have to properly figure out exactly how it works as well so I can make my own.

There are other suggestions around, eg
	https://stackoverflow.com/questions/20778568/how-to-make-an-inset-drop-shadow-in-svg


Originally I'd thought that I might have to create the body as a donut shape of some sort and apply a css drop shadow and somehow mask out the outer shadow.
I imagine there are probably a few different ways of doing this sort of thing; a radial gradient background of some sort might be another idea.
This is going to be a bit of trial and error generally to see what works and what looks good.
One thing I'm a bit worried about is that some techniques are probably more expensive/slower  - I think some of the SVG filter effects are known to be a bit slow for example.
I'll have a bit of a look around to see if there's any accepted wisdom for this sort of thing.

I also need to figure out how effectively svg filters can be styled with css - I've quickly done the flood, but would like a whole stack more control over these before I go really far down this path.
I'd like to be able to avoid defining multiple similar shadow `<filter/>`s if I can avoid it.


**Note** - it might end up being easier and cheaper to use a drop-shadow and clip


Markers
-------

Want to spend some time on markers.
Will start with the secor label code as I think the rotations I want will work similarly.

Have quickly chopped something together that looks like it's working, but still need to figure a few things out.

There are a few cryptic statements in here:

https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Element/use

...

In general there are actually a few different ways to reuse content in SVG, I've only really taken beginning steps with this stuff so far.
I think most drawing elements with an id can be reused with a `use` (including things in external files), but in practise it's usually things defined in `defs`.

A couple of interest here are `symbol` and `marker` that have some extra features.

Markers can be automatically applied along paths with CSS (probably even invisible ones), and can have custom start, middle and ends (prob no complex rotation though).

`Symbol` requires `use` so better if viewbox & sizing control needed, however the refX and refY attributes don't appear to be implemented in browsers yet:
https://stackoverflow.com/questions/63967987/svg-symbols-refx-refx-attribute-and-placing-a-symbol-relative-to-its-center

Without refX+refY on symbol I think the thing to do is make the the symbols centred on 0 (which I usually do anyway).
Actually without refX+refY symbol is going to be hard to use programmatically until I figure something else out.
Have had better results just `use`ing a group or basic element.


Turns out there is a native rotation implementation for markers though, so for a lot of basic needs these will do:

	orient="auto"
	orient="auto-start-reverse"

https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Attribute/orient


Styling is also a bit trickier with `use` - will add details as I figure it out.


Season cutout
-------------

I want to start hacking on the season cutout next, but I also feel liekthe current body/face arrangement could use some work.
Going to change the current 'body' to become the face, and add an extra body layer.

Have it going, had wanted to add some emojis but can't seem to get them to work - will need to figure out if there's a reliable way to do that.



Wrapup
------

Just about done here, have tentatively added some hour counters which I'm undecided about - might try to inset them properly.

Wrapup notes:

* Split clock face in two and positioned with translates
* Added graph paper for wireframe background
* Hand code split up
* A whole stack of changes and improvements to allow for calculating the custom angular contexts of dials
* Some updates for the wall-clock theme
* Start using small classes for things like date ranges, radian deltas
* Markers drawn with `use` this time; also experimenting with path markers
* Various experiments with inset shadows - going with standard css filter + clip for now
* Make getDateLabel a bit more flexible
* Add rotating season dial

Follow up:
* Get a warning lamp or three going - prob need to figure out emojis first
* Maybe inset & space the hour counters to look more like odometers/tripmeters
* Probably a bunch of mess
* Get the wireframe background to switch on the grid properly - prob need to draw separately
* Maybe add another body layer to have separate outer and inset shadows



Follow ups
----------

I think I've figured out the emoji problem in firefox: some stroke and font-style settings stop them rendering; so will update some things.

Want to add

```
⚠⛍⛐⛛🌡⚠️
🎃🎄🎆🥚
💘

```

Trying to cut the star out of the body, but it's proving a little tricky, trying a few different things.
I *think* it has to be part of the same path (not 100% sure though), so trying to get the star in with stock drawing coordinates.
Shrinking it isn't hard, but moving it flexibly requires using relative moves, which i don't have right now.
Might have to add it as an option to the polygon.

<path class="star" d="M -52 193 l 0 -386 l 193 335 l -335 -193 l 386 0 l -335 193 l 193 -335 l 0 386 l -193 -335 l 335 193 l -386 0 l 335 -193  Z"/>

This path works as a cutout, might want to simplify or make a little smaller though.

### Warning lamps

Need a plan. I'd like at least one lamp each for the month and year dials, but could potentially have more if I had content+justification.
For the month side I'd probably go with some basic day type decorations working on weekdays, relaxing on weekends, but could get more creative/sillier if I wanted.
	Weekdays: Wed🐪
	Weekend: 🏖️

For years there are absolutely tons of things you could do - national days, international days, holidays, festivals etc.
I think this time around I'll start with some basics - christmas, new years etc - and figure out the rest later on.

Also need some sort of way to handle multiple events on a day.
The simplest would be to just return an array, but some kind of category or grouping would be better.



face backing
	seasonFace